# Hash表

什么时候使用hash？当我们遇到了需要快速判断一个元素是否出现在集合里的时候，我们就需要使用hash算法。

本质上使用了空间换取时间，使用额外的数组（map/set）来存储数据，实现快速查找。

## 常见的三种Hash结构

- array
- set
- map

在c++中set和map分别提供了以下三种数据结构

### set

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

`std::unordered_set`底层实现是**哈希表**，`std::set`, `std::multiset`的底层实现是**红黑树**，红黑树是一种**平衡二叉树**，所以红黑树的key是有序的，但是key是不能够修改的，如果一点修改了key会导致整个树的错乱，只能删除和增加。

在我们需要使用set来结局hash问题时

1. 优先使用`unorder_set`，因为他的**查询、增删效率最高**
2. 如果需要集合**有序**，那么我们就使用`set`
3. 如果要求不仅有序还有**重复数据**的话，我们就是用`multiset`

### map

map本质上是一个key-value的数据结构。因为map的底层实现是红黑树，
所以，在map中对key是有限制的，但是对value没有

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

`std::unordered_map`底层实现为`哈希表`，`std::map`和`std::multimap` 的底层实现是`红黑树`。
同理，`std::map` 和`std::multimap` 的key也是有序的
